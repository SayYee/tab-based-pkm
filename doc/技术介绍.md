# 核心元数据类

`com.sayyi.software.tbp.common.FileMetadata`即为系统维护的核心元数据类，所有的操作都是基于这个类进行。为简便起见，省略了部分内容

```java
package com.sayyi.software.tbp.common;

import lombok.Data;

import java.util.Set;

/**
 * 文件元数据
 * @author SayYi
 */
@Data
public class FileMetadata {

    /**
     * 文件id
     */
    private long id;
    /**
     * 文件名称
     */
    private String filename;
    /**
     * 资源类型，会影响资源的操作方式。
     */
    private int resourceType = 1;
    /**
     * 资源路径。如果是本地文件，则是相对路径；如果是网络资源，则是链接地址
     */
    private String resourcePath;
    /**
     * 标签集合
     */
    private Set<String> tags;

    /**
     * 创建时间戳
     */
    private long createTime;
    /**
     * 最后一次打开时间戳。
     */
    private long lastOpenTime;

}

```



# 核心功能

## 核心功能实现类

系统的核心功能，在`com.sayyi.software.tbp.core.facade.PkmFunction`中进行了描述。系统提供了两个实现。

一个是`com.sayyi.software.tbp.core.facade.DefaultPkmFunction`，这个类使用的是直接通过java方法调用的方式来执行。

另一个是`com.sayyi.software.tbp.nio.NioPkmFunction`，这个类通过tcp客户端与tcp server进行交互。

所有的参数都会被转换成字节数组，经过多个处理器进行处理。



## 请求处理器

系统提供了三个处理器，都在`com.sayyi.software.tbp.core.flow.processor`包中：

- PrepProcessor：主要负责本地文件处理，包括创建、删除、修改、打开等。
- SyncProcessor：负责操作信息持久化
- FinalProcessor：负责根据请求信息，对加载到内存中的数据进行修改。

这些处理器的设计对zookeeper中的数据处理过程进行了一些借鉴。不过zookeeper中使用的switch-case的方式来处理不同类型的请求，我在这里利用反射，把不同类型的请求映射到了不同的方法中进行处理。



系统在启动的时候，会把所有的元数据加载到内存当中，这样可以数据操作的效率。后续用户进行操作时，操作信息会被SyncProcessor处理器持久化到本地，因为是面向个人使用的，所以操作会被立刻持久化到本地的request文件中，随后再到达FinalProcessor中，针对内存数据进行操作。

每次系统启动时，会基于完整快照snapshot文件加载数据，然后从request中获取快照文件上执行的操作信息，恢复内存数据，同时将最终结果制作为最新的snapshot文件进行存储。全量+增量的模式，可以保证数据的可靠性，同时提高数据的恢复效率。



# 并发安全

为了支持多端操作，系统提供了并发安全的保证。所有的请求都会经过`com.sayyi.software.tbp.core.PkmServiceImpl`中的内部类`ProcessorThread`，这个类从并发安全的`LinkedBlockingQueue<Object[]> requestPair`中获取请求，串行处理。



# NIO网络通信

采用的accept+selector的处理模式，参考zookeeper对数据进行序列化，根据数据长度来进行拆粘包的处理。